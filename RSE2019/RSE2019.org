#+TITLE: Developing Fortran using Python and Literate Programming
#+AUTHOR: Paul Bartholomew, Sylvain Laizet
#+DATE: September 2019

#+OPTIONS: toc:t
#+OPTIONS: H:2

#+STARTUP: beamer
#+LATEX_CLASS: beamer

#+LATEX_HEADER: \usecolortheme{Imperial}
#+LATEX_HEADER: \usepackage{booktabs}
#+LATEX_HEADER: \usepackage{caption}
#+LATEX_HEADER: \usepackage{subcaption}
#+LATEX_HEADER: \usepackage{amsfonts}
#+LATEX_HEADER: \usepackage{epstopdf}
#+LATEX_HEADER: \usepackage{multimedia}

# Use UK date format
#+LATEX_HEADER: \usepackage{datetime}
#+LATEX_HEADER: \let\dateUKenglish\relax
#+LATEX_HEADER: \newdateformat{dateUKenglish}{\THEDAY~\monthname[\THEMONTH] \THEYEAR}

# Imperial College Logo, not to be changed!
#+LATEX_HEADER: \institute{\includegraphics[height=0.7cm]{Imperial_1_Pantone_solid.eps}}

# # To repeat TOC at each section
# #+LATEX_HEADER: \AtBeginSection[]{\begin{frame}<beamer>\frametitle{\insertsection}\tableofcontents[currentsection]\end{frame}}

* Introduction

** My programming career

Seems to have gone backwards:

#+CAPTION: "Progress"
#+ATTR_LATEX: :width 0.9\textwidth
[[./figures/lang-progress.png]]

#+CAPTION: Experience
#+ATTR_LATEX: :width 0.9\textwidth
[[./figures/lang-experience.png]]

** Literate programming: an old idea

- Introduced by Donald Knuth in 1984
#+begin_quote
I believe that the time is ripe for significantly better documentation of programs, and that we can
best achieve this by considering programs to be works of literature.
Hence, my title: "Literate Programming."
#+end_quote
#+begin_quote
Instead of imagining that our main task is to instruct a computer what to do, let us concentrate on
explaining to human beings what we want a computer to do.
#+end_quote
- Doesn't seem to have caught on
- Could be well suited for scientific computing

** Exploring literate programming

*** Left
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

- Fits very well for producing reports
- Can combine
  - Processing of result
  - Display of result
  - Discussion of results
- =Jupyter= does something like this
- Can we take this idea further?

*** Right
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+CAPTION: Sections of report on Taylor Green Vortex
#+ATTR_LATEX: :width \columnwidth
[[./figures/tgv-literate.png]]

** The problem

- =Incompact3d= is a CFD code for simulating incompressible turbulent flows
- Want to develop a free-surface solver

#+CAPTION: Water surface with submerged obstacles
#+ATTR_LATEX: :width 0.575 \textwidth
[[./figures/mcsherry-freesurface.png]]

** The problem (cont.)

*** Left
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

- The schemes implemented in =Incompact3d= are ill-suited to these problems

#+CAPTION: Illustration of Gibbs' phenomenon
#+ATTR_LATEX: :width \columnwidth
[[./figures/gibbs-phenomenon.png]]

*** Right
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

- =WENO= schemes provide high-order accuracy without being susceptible to oscillations
  - Could simply code this in Fortran
  - Would like to leave behind something that is understandable
  - Testing code /inside/ a complex program is difficult

* Implementing a =WENO= scheme

** ~WENO~ schemes

- Evaluate several stencils

#+ATTR_LATEX: :width 0.6\textwidth
[[./figures/weno-stencil.png]]

- Check for "/smoothness/"
- Combine /smooth/ stencils to obtain higher order approximation

** ~WENO~ gradient computation

*** Left
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

**** Weighted combination of stenciles
\begin{equation*}
  \begin{split}
    \left.\frac{\partial\phi}{\partial x}\right|_i &=
    \begin{cases}
      \left.\frac{\partial\phi}{\partial x}\right|^-_i & u > 0 \\
      \left.\frac{\partial\phi}{\partial x}\right|^+_i & u < 0
    \end{cases} \\
    \left.\frac{\partial\phi}{\partial x}\right|^{\pm}_i &= \left[ \omega_1 \left( 2 q^{\pm}_1 + 7
        q^{\pm}_2 + 11 q^{\pm}_3 \right) \right.  \\
    & + \omega_2 \left( -q^{\pm}_2 + 5q^{\pm}_3 + 2q^{\pm}_4 \right) \\
    & \left.+ \omega_3 \left( 2q^{\pm}_3 + 5q^{\pm}_4 - q^{\pm}_5 \right) \right] / 6
  \end{split}
\end{equation*}

*** Right
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+CAPTION: Evaluation of \partial\phi/\partial{}x using fifth-order =WENO= scheme.
#+NAME: src:calcgrad.f90
#+begin_src f90
  gradphi(i,j,k)=&
       w1*(2.0*q1-7.0*q2+11.0*q3)&
       +w2*(-q2+5.0*q3+2.0*q4)&
       +w3*(2.0*q3+5.0*q4-q5)
  gradphi(i,j,k)=gradphi(i,j,k)/6.0
#+end_src

** Stencil computation

*** Left
:PROPERTIES:
:BEAMER_COL: 0.6
:END:

**** Stencil definition
\begin{equation*}
  \begin{split}
    q^{\pm}_1 = \frac{\phi_{i-2} - \phi_{i-3}}{\Delta x},&\ 
    q^{\pm}_2 = \frac{\phi_{i-1} - \phi_{i-2}}{\Delta x}, \\
    q^{\pm}_3 = \frac{\phi_i - \phi_{i-1}}{\Delta x},&\
    q^{\pm}_4 = \frac{\phi_{i+1} - \phi_i}{\Delta x}, \\
    q^{\pm}_5 =& \frac{\phi_{i+2} - \phi_{i+1}}{\Delta x},
  \end{split}
\end{equation*}

- They are /symmetric/ about the gradient evaluation point $x_i$

*** Right
:PROPERTIES:
:BEAMER_COL: 0.4
:END:

#+CAPTION: Stencil evaluation for fifth-order =WENO= scheme.
#+NAME: src:calcq.f90
#+begin_src f90
  q1=dsign*(phi(im2,jm2,km2)-phi(im3,jm3,km3))/deltax
  q2=dsign*(phi(im1,jm1,km1)-phi(im2,jm2,km2))/deltax
  q3=dsign*(phi(i,j,k)-phi(im1,jm1,km1))/deltax
  q4=dsign*(phi(ip1,jp1,kp1)-phi(i,j,k))/deltax
  q5=dsign*(phi(ip2,jp2,kp2)-phi(ip1,jp1,kp1))/deltax
#+end_src

** The stencil weights

*** Left
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

**** The key to =weno=
- Smooth regions have $\approx$ weights $\rightarrow$ high-order
- If stencil $k$ contains discontinuity $\omega_{k}\rightarrow0$

**** Definition
\begin{equation*}
  \omega_k = \frac{\alpha_k}{\sum_l \alpha_l}
\end{equation*}

*** Right
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+CAPTION: Weight calculation for fifth-order =WENO= scheme.
#+NAME: src:calcweights.f90
#+begin_src f90
  w1 = a1 / (a1 + a2 + a3)
  w2 = a2 / (a1 + a2 + a3)
  w3 = a3 / (a1 + a2 + a3)
#+end_src

** The weight coefficients

*** Left
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+begin_export latex
\begin{block}{Definition}
  \begin{equation*}
    \alpha_k = \frac{C_k}{{\left( IS_k + \varepsilon \right)}^2}
  \end{equation*}
\end{block}
#+end_export

#+CAPTION: Calculating the weighting coefficients
#+NAME: src:calc-weight-coeffs.f90
#+begin_src f90 :noweb no-export
  <<src:calc-indicators.f90>>
  <<src:calc-a1.f90>>
  <<src:calc-a2.f90>>
  <<src:calc-a3.f90>>
#+end_src

#+CAPTION: Calculating coefficient $\alpha_1$
#+NAME: src:calc-a1.f90
#+begin_src f90
  a1=1.0/(e+is1)**2/10.0
#+end_src
#+NAME: src:calc-a2.f90
#+begin_src f90 :exports none
  a2=6.0/(e+is2)**2/10.0
#+end_src
#+NAME: src:calc-a3.f90
#+begin_src f90 :exports none
  a3=3.0/(e+is3)**2/10.0
#+end_src

*** Right
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+CAPTION: Calculating the smoothness indicators
#+NAME: src:calc-indicators.f90
#+begin_src f90 :noweb no-export
  <<src:calc-is1.f90>>
  <<src:calc-is2.f90>>
  <<src:calc-is3.f90>>
#+end_src

#+CAPTION: Calculating $IS_1$
#+NAME: calc-is1.f90
#+begin_src f90
  is1=(13.0/12.0) &
       ,*(phi(im2,jm2,km2)-2.0*phi(im1,jm1,km1)+phi(i,j,k))**2 &
       +(phi(im2,jm2,km2)-4.0*phi(im1,jm1,km1)+three*phi(i,j,k))**2 &
       /4.0
#+end_src
#+NAME: calc-is2.f90
#+begin_src f90 :exports none
  is2=(13.0/12.0)*(phi(im1,jm1,km1)-2.0*phi(i,j,k)+phi(ip1,jp1,kp1))**2&
       +(phi(im1,jm1,km1)-phi(ip1,jp1,kp1))**2/4.0
#+end_src
#+NAME: calc-is3.f90
#+begin_src f90 :exports none
  is3=(13.0/12.0)*(phi(i,j,k)-2.0*phi(ip1,jp1,kp1)+phi(ip2,jp2,kp2))**2&
       +(3.0*phi(i,j,k)-4.0*phi(ip1,jp1,kp1)+phi(ip2,jp2,kp2))**2/4.0
#+end_src

** The =weno= module

*** Left
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+CAPTION: The ~weno~ module.
#+NAME: src:weno.f90
#+begin_src f90 :noweb no-export :tangle weno.f90
  module weno
    implicit none
    private
    public :: weno5
  contains
    <<src:weno5.f90>>
  endmodule weno
#+end_src

*** Right
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+CAPTION: =WENO= subroutine definition.
#+NAME: src:weno5.f90
#+begin_src f90 :noweb no-export
  subroutine weno5(gradphi, phi, advvel, &
       axis, bc0, bcn, &
       isize, jsize, ksize, &
       dx, dy, dz)
    implicit none
    <<src:weno5-declarations.f90>>
    <<src:weno5-setup.f90>>
    do k = kstart, kend
       do j = jstart, jend
          !! Note, if axis==2 and y is stretched, need to set deltax here
          do i = istart, iend
             <<src:sign.f90>>
             <<src:calcq.f90>>
             <<src:calc-weight-coeffs.f90>>
             <<src:calcweights.f90>>
             <<src:calcgrad.f90>>
          enddo
          <<src:bcx.f90>>
       enddo
       <<src:bcy.f90>>
    enddo
    <<src:bcz.f90>>
  endsubroutine weno5
#+end_src

* Testing

** Testing

*** Approaches to testing
- Add module directly to =Xcompact3d=
- Test module independently before adding to =Xcompact3d=

*** Using =f2py=
Can easily build =weno.f90= as a standalone module and call from Python to test
- Easy to setup test cases
- Rapid feedback

** Testing on a smooth function

*** Left
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+begin_export latex
\begin{block}{Consider}
  \begin{equation*}
    \begin{split}
      f\left(x\right) &= \sin\left(x\right) \\
      \Rightarrow f'\left(x\right) &= \cos\left(x\right)
    \end{split}
  \end{equation*}
\end{block}
#+end_export


#+CAPTION: Testing the x-derivative
#+begin_src python :noweb yes
  <<src:xinit.py>>
  <<src:gradx.py>>
  <<src:plotx.py>>
#+end_src

*** Right
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+CAPTION: Comparison of numerical and analytical derivative of $f\left(x\right)=\sin\left(x\right)$
#+ATTR_LATEX: :width \columnwidth
[[./figures/weno-smoothx.eps]]

** Application to a pure advection equation

*** Left
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

**** Motivating implementation
\begin{equation*}
  \frac{\partial\phi}{\partial t} + \boldsymbol{u}\cdot\boldsymbol{\nabla}\phi = 0
\end{equation*}

- In periodic domain, $\phi$ simply moves with velocity $u$
- Simple to implement in =Python= using ~weno5~ + ~scipy~'s ode solvers
- Domain $x\in\left[-1, 1\right]$ discretised with 200 points

*** Right
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+CAPTION: Comparison of analytical solution and numerical solutions at $t=8, 10$
#+ATTR_LATEX: :width \columnwidth
[[./figures/adv_test.eps]]

* Conclusion

** Conclusion

*** Left
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

- A =weno= scheme was implemented and has been incorporated into =Xcompact3d=
- @@latex:\color{green}{\textbf{+}}@@ :: Using literate programming we can write programs in a way
     that makes sense to us
- @@latex:\color{green}{\textbf{+}}@@ :: Explanatory document automatically generated
- @@latex:\color{red}{\textbf{--}}@@ :: Tooling isn't as strong as traditional tooling

*** Right
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

- Using =f2py= simplifies testing
- @@latex:\color{green}{\textbf{+}}@@ :: Quicker feedback on tests
- @@latex:\color{green}{\textbf{+}}@@ :: Can explore results using =Python=
- @@latex:\color{green}{\textbf{+}}@@ :: Using literate programming can embed testing + results into
     same source document

** Code availability

- This talk is available on github at[fn:1]
  - It is /runnable/
  - "Compiling" the talk's source with =emacs= produces this pdf + =weno.f90= + =Python= testing code
- Xcompact3d is also available on github at[fn:2]
  - Current release preview is on the =release= branch

*** Acknowledgement

Work undertaken as part of an =eCSE= project funded by =EPCC=
#+ATTR_LATEX: :width 0.4\textwidth
[[./figures/archer-logo.png]]

* Footnotes

[fn:1] https://github.com/pbartholomew08/presentations

[fn:2] https://github.com/xcompact3d/Incompact3d 

* Appendix                                                         :noexport:

Code that is not interesting to present is defined here, it will be tangled but not shown in the
woven document.

** Setup code

#+NAME: src:weno5-setup.f90
#+begin_src f90
    !! Defaults
    istart = 1
    iend = isize
    jstart = 1
    jend = jsize
    kstart = 1
    kend = ksize

    istep = 0
    jstep = 0
    kstep = 0

    if (axis==1) then
       deltax = dx

       istart = 4
       iend = isize - 3
       istep = 1
    elseif (axis==2) then
       deltax = dy

       jstart = 4
       jend = jsize - 3
       jstep = 1
    elseif (axis==3) then
       deltax = dz

       kstart = 4
       kend = ksize - 3
       kstep = 1
    else
       print *, "ERROR: Invalid axis passed to WENO5"
       stop
    endif
#+end_src

** Upwinding

#+CAPTION: Stencil sign and index offsets.
#+NAME: src:sign.f90
#+begin_src f90
  if (advvel(i, j, k) > zero) then
     dsign = one

     istep = istep
     jstep = jstep
     kstep = kstep
  elseif (advvel(i, j, k) < zero) then
     dsign = -one

     istep = -istep
     jstep = -jstep
     kstep = -kstep
  else
     gradphi(i, j, k) = zero
     cycle
  endif

  im1 = i - 1 * istep
  im2 = i - 2 * istep
  im3 = i - 3 * istep
  ip1 = i + 1 * istep
  ip2 = i + 2 * istep

  jm1 = j - 1 * jstep
  jm2 = j - 2 * jstep
  jm3 = j - 3 * jstep
  jp1 = j + 1 * jstep
  jp2 = j + 2 * jstep

  km1 = k - 1 * kstep
  km2 = k - 2 * kstep
  km3 = k - 3 * kstep
  kp1 = k + 1 * kstep
  kp2 = k + 2 * kstep
#+end_src

** Boundary conditions

*** X Boundary

#+CAPTION: x-boundary conditions
#+NAME: src:bcx.f90
#+begin_src f90 :noweb no-export
  if (axis==1) then
     jm1 = j
     jm2 = j
     jm3 = j
     jp1 = j
     jp2 = j

     km1 = k
     km2 = k
     km3 = k
     kp1 = k
     kp2 = k

     if ((bc0==0).and.(bcn==0)) then
        i = 1
        if (advvel(i, j, k) == zero) then
           gradphi(i, j, k) = zero
        else
           if (advvel(i, j, k) > zero) then
              dsign = one

              im1 = isize
              im2 = isize - 1
              im3 = isize - 2
              ip1 = i + 1
              ip2 = i + 2
           else
              dsign = -one

              im1 = i + 1
              im2 = i + 2
              im3 = i + 3
              ip1 = isize
              ip2 = isize - 1
           endif
           <<src:calcq.f90>>
           <<src:calc-weight-coeffs.f90>>
           <<src:calcweights.f90>>
           <<src:calcgrad.f90>>
        endif

        i = 2
        if (advvel(i, j, k) == zero) then
           gradphi(i, j, k) = zero
        else
           if (advvel(i, j, k) > zero) then
              dsign = one

              im1 = i - 1
              im2 = isize
              im3 = isize - 1
              ip1 = i + 1
              ip2 = i + 2
           else
              dsign = -one

              im1 = i + 1
              im2 = i + 2
              im3 = i + 3
              ip1 = i - 1
              ip2 = isize
           endif
           <<src:calcq.f90>>
           <<src:calc-weight-coeffs.f90>>
           <<src:calcweights.f90>>
           <<src:calcgrad.f90>>
        endif

        i = 3
        if (advvel(i, j, k) == zero) then
           gradphi(i, j, k) = zero
        else
           if (advvel(i, j, k) > zero) then
              dsign = one

              im1 = i - 1
              im2 = i - 2
              im3 = isize
              ip1 = i + 1
              ip2 = i + 2
           else
              dsign = -one

              im1 = i + 1
              im2 = i + 2
              im3 = i + 3
              ip1 = i - 1
              ip2 = i - 2
           endif
           <<src:calcq.f90>>
           <<src:calc-weight-coeffs.f90>>
           <<src:calcweights.f90>>
           <<src:calcgrad.f90>>
        endif

        i = isize
        if (advvel(i, j, k)==zero) then
           gradphi(i, j, k) = zero
        else
           if (advvel(i, j, k) > zero) then
              dsign = one

              im1 = i - 1
              im2 = i - 2
              im3 = i - 3
              ip1 = 1
              ip2 = 2
           else
              dsign = -one

              im1 = 1
              im2 = 2
              im3 = 3
              ip1 = i - 1
              ip2 = i - 2
           endif
           <<src:calcq.f90>>
           <<src:calc-weight-coeffs.f90>>
           <<src:calcweights.f90>>
           <<src:calcgrad.f90>>
        endif

        i = isize - 1
        if (advvel(i, j, k) == zero) then
           gradphi(i, j, k) = zero
        else
           if (advvel(i, j, k) > zero) then
              dsign = one

              im1 = i - 1
              im2 = i - 2
              im3 = i - 3
              ip1 = i + 1
              ip2 = 1
           else
              dsign = -one

              im1 = i + 1
              im2 = 1
              im3 = 2
              ip1 = i - 1
              ip2 = i - 2
           endif
           <<src:calcq.f90>>
           <<src:calc-weight-coeffs.f90>>
           <<src:calcweights.f90>>
           <<src:calcgrad.f90>>
        endif

        i = isize - 2
        if (advvel(i, j, k) == zero) then
           gradphi(i, j, k) = zero
        else
           if (advvel(i, j, k) > zero) then
              dsign = one

              im1 = i - 1
              im2 = i - 2
              im3 = i - 3
              ip1 = i + 1
              ip2 = i + 2
           else
              dsign = -one

              im1 = i + 1
              im2 = i + 2
              im3 = 1
              ip1 = i - 1
              ip2 = i - 2
           endif
           <<src:calcq.f90>>
           <<src:calc-weight-coeffs.f90>>
           <<src:calcweights.f90>>
           <<src:calcgrad.f90>>
        endif
     else
        !! Use second order
        i = 1
        if (bc0==1) then ! Zero grad
           gradphi(i, j, k) = zero
        else ! Fixed value
           gradphi(i, j, k) = (phi(i + 1, j, k) - phi(i, j, k)) / dx
        endif
        do i = 2, 3
           gradphi(i, j, k) = (phi(i + 1, j, k) - phi(i - 1, j, k)) / (two * dx)
        enddo

        do i = isize - 2, isize - 1
           gradphi(i, j, k) = (phi(i + 1, j, k) - phi(i - 1, j, k)) / (two * dx)
        enddo
        i = isize
        if (bcn==1) then ! Zero grad
           gradphi(i, j, k) = zero
        else
           gradphi(i, j, k) = (phi(i, j, k) - phi(i - 1, j, k)) / dx
        endif
     endif
  endif
#+end_src

*** Y Boundary

#+CAPTION: y-boundary conditions
#+NAME: src:bcy.f90
#+begin_src f90 :noweb no-export
  if (axis==2) then
     km1 = k
     km2 = k
     km3 = k
     kp1 = k
     kp2 = k

     if ((bc0==0).and.(bcn==0)) then
        do i = 1, isize
           im1 = i
           im2 = i
           im3 = i
           ip1 = i
           ip2 = i

           j = 1
           if (advvel(i, j, k)==zero) then
              gradphi(i, j, k) = zero
           else
              if (advvel(i, j, k) > zero) then
                 dsign = one

                 jm1 = jsize
                 jm2 = jsize - 1
                 jm3 = jsize - 2
                 jp1 = j + 1
                 jp2 = j + 2
              else
                 dsign = -one

                 jm1 = j + 1
                 jm2 = j + 2
                 jm3 = j + 3
                 jp1 = jsize
                 jp2 = jsize - 1
              endif
              <<src:calcq.f90>>
              <<src:calc-weight-coeffs.f90>>
              <<src:calcweights.f90>>
              <<src:calcgrad.f90>>
           endif

           j = 2
           if (advvel(i, j, k)==zero) then
              gradphi(i, j, k) = zero
           else
              if (advvel(i, j, k) > zero) then
                 dsign = one

                 jm1 = j - 1
                 jm2 = jsize
                 jm3 = jsize - 1
                 jp1 = j + 1
                 jp2 = j + 2
              else
                 dsign = -one

                 jm1 = j + 1
                 jm2 = j + 2
                 jm3 = j + 3
                 jp1 = j - 1
                 jp2 = jsize
              endif
              <<src:calcq.f90>>
              <<src:calc-weight-coeffs.f90>>
              <<src:calcweights.f90>>
              <<src:calcgrad.f90>>
           endif

           j = 3
           if (advvel(i, j, k)==zero) then
              gradphi(i, j, k) = zero
           else
              if (advvel(i, j, k) > zero) then
                 dsign = one

                 jm1 = j - 1
                 jm2 = j - 2
                 jm3 = jsize
                 jp1 = j + 1
                 jp2 = j + 2
              else
                 dsign = -one

                 jm1 = j + 1
                 jm2 = j + 2
                 jm3 = j + 3
                 jp1 = j - 1
                 jp2 = j - 2
              endif
              <<src:calcq.f90>>
              <<src:calc-weight-coeffs.f90>>
              <<src:calcweights.f90>>
              <<src:calcgrad.f90>>
           endif

           j = jsize
           if (advvel(i, j, k) == zero) then
              gradphi(i, j, k) = zero
           else
              if (advvel(i, j, k) > zero) then
                 dsign = one

                 jm1 = j - 1
                 jm2 = j - 2
                 jm3 = j - 3
                 jp1 = 1
                 jp2 = 2
              else
                 dsign = -one

                 jm1 = 1
                 jm2 = 2
                 jm3 = 3
                 jp1 = j - 1
                 jp2 = j - 2
              endif
              <<src:calcq.f90>>
              <<src:calc-weight-coeffs.f90>>
              <<src:calcweights.f90>>
              <<src:calcgrad.f90>>
           endif

           j = jsize - 1
           if (advvel(i, j, k)==zero) then
              gradphi(i, j, k) = zero
           else
              if (advvel(i, j, k) > zero) then
                 dsign = one

                 jm1 = j - 1
                 jm2 = j - 2
                 jm3 = j - 3
                 jp1 = j + 1
                 jp2 = 1
              else
                 dsign = -one

                 jm1 = j + 1
                 jm2 = 1
                 jm3 = 2
                 jp1 = j - 1
                 jp2 = j - 2
              endif
              <<src:calcq.f90>>
              <<src:calc-weight-coeffs.f90>>
              <<src:calcweights.f90>>
              <<src:calcgrad.f90>>
           endif

           j = jsize - 2
           if (advvel(i, j, k)==zero) then
              gradphi(i, j, k) = zero
           else
              if (advvel(i, j, k) > zero) then
                 dsign = one

                 jm1 = j - 1
                 jm2 = j - 2
                 jm3 = j - 3
                 jp1 = j + 1
                 jp2 = j + 2
              else
                 dsign = -one

                 jm1 = j + 1
                 jm2 = j + 2
                 jm3 = 1
                 jp1 = j - 1
                 jp2 = j - 2
              endif
              <<src:calcq.f90>>
              <<src:calc-weight-coeffs.f90>>
              <<src:calcweights.f90>>
              <<src:calcgrad.f90>>
           endif
        enddo
     else
        do i = 1, isize
           !! Use second order
           j = 1
           if (bc0==1) then ! Zero grad
              gradphi(i, j, k) = zero
           else ! Fixed value
              gradphi(i, j, k) = (phi(i, j + 1, k) - phi(i, j, k)) / dy
           endif
           do j = 2, 3
              gradphi(i, j, k) = (phi(i, j + 1, k) - phi(i, j - 1, k)) / (two * dy)
           enddo

           do j = jsize - 2, jsize - 1
              gradphi(i, j, k) = (phi(i, j + 1, k) - phi(i, j - 1, k)) / (two * dy)
           enddo
           j = jsize
           if (bcn==1) then ! Zero grad
              gradphi(i, j, k) = zero
           else
              gradphi(i, j, k) = (phi(i, j, k) - phi(i, j - 1, k)) / dy
           endif
        enddo
     endif
  endif
#+end_src

*** Z Boundary

#+CAPTION: z-boundary conditions
#+NAME: src:bcz.f90
#+begin_src f90 :noweb no-export
  if (axis==3) then
     if ((bc0==0).and.(bcn==0)) then
        do j = 1, jsize
           do i = 1, isize
              jm1 = j
              jm2 = j
              jm3 = j
              jp1 = j
              jp2 = j

              im1 = i
              im2 = i
              im3 = i
              ip1 = i
              ip2 = i

              k = 1
              if (advvel(i, j, k)==zero) then
                 gradphi(i, j, k) = zero
              else
                 if (advvel(i, j, k) > zero) then
                    dsign = one

                    km1 = ksize
                    km2 = ksize - 1
                    km3 = ksize - 2
                    kp1 = k + 1
                    kp2 = k + 2
                 else
                    dsign = -one

                    km1 = k + 1
                    km2 = k + 2
                    km3 = k + 3
                    kp1 = ksize
                    kp2 = ksize - 1
                 endif
                 <<src:calcq.f90>>
                 <<src:calc-weight-coeffs.f90>>
                 <<src:calcweights.f90>>
                 <<src:calcgrad.f90>>
              endif

              k = 2
              if (advvel(i, j, k)==zero) then
                 gradphi(i, j, k) = zero
              else
                 if (advvel(i, j, k) > zero) then
                    dsign = one

                    km1 = k - 1
                    km2 = ksize
                    km3 = ksize - 1
                    kp1 = k + 1
                    kp2 = k + 2
                 else
                    dsign = -one

                    km1 = k + 1
                    km2 = k + 2
                    km3 = k + 3
                    kp1 = k - 1
                    kp2 = ksize
                 endif
                 <<src:calcq.f90>>
                 <<src:calc-weight-coeffs.f90>>
                 <<src:calcweights.f90>>
                 <<src:calcgrad.f90>>
              endif

              k = 3
              if (advvel(i, j, k)==zero) then
                 gradphi(i, j, k) = zero
              else
                 if (advvel(i, j, k) > zero) then
                    dsign = one

                    km1 = k - 1
                    km2 = k - 2
                    km3 = ksize
                    kp1 = k + 1
                    kp2 = k + 2
                 else
                    dsign = -one

                    km1 = k + 1
                    km2 = k + 2
                    km3 = k + 3
                    kp1 = k - 1
                    kp2 = k - 2
                 endif
                 <<src:calcq.f90>>
                 <<src:calc-weight-coeffs.f90>>
                 <<src:calcweights.f90>>
                 <<src:calcgrad.f90>>
              endif

              k = ksize
              if (advvel(i, j, k) == zero) then
                 gradphi(i, j, k) = zero
              else
                 if (advvel(i, j, k) > zero) then
                    dsign = one

                    km1 = k - 1
                    km2 = k - 2
                    km3 = k - 3
                    kp1 = 1
                    kp2 = 2
                 else
                    dsign = -one

                    km1 = 1
                    km2 = 2
                    km3 = 3
                    kp1 = k - 1
                    kp2 = k - 2
                 endif
                 <<src:calcq.f90>>
                 <<src:calc-weight-coeffs.f90>>
                 <<src:calcweights.f90>>
                 <<src:calcgrad.f90>>
              endif

              k = ksize - 1
              if (advvel(i, j, k) == zero) then
                 gradphi(i, j, k) = zero
              else
                 if (advvel(i, j, k) > zero) then
                    dsign = one

                    km1 = k - 1
                    km2 = k - 2
                    km3 = k - 3
                    kp1 = k + 1
                    kp2 = 1
                 else
                    dsign = -one

                    km1 = k + 1
                    km2 = 1
                    km3 = 2
                    kp1 = k - 1
                    kp2 = k - 2
                 endif
                 <<src:calcq.f90>>
                 <<src:calc-weight-coeffs.f90>>
                 <<src:calcweights.f90>>
                 <<src:calcgrad.f90>>
              endif

              k = ksize - 2
              if (advvel(i, j, k) == zero) then
                 gradphi(i, j, k) = zero
              else
                 if (advvel(i, j, k) > zero) then
                    dsign = one

                    km1 = k - 1
                    km2 = k - 2
                    km3 = k - 3
                    kp1 = k + 1
                    kp2 = k + 2
                 else
                    dsign = -one

                    km1 = k + 1
                    km2 = k + 2
                    km3 = 1
                    kp1 = k - 1
                    kp2 = k - 2
                 endif
                 <<src:calcq.f90>>
                 <<src:calc-weight-coeffs.f90>>
                 <<src:calcweights.f90>>
                 <<src:calcgrad.f90>>
              endif
           enddo
        enddo
     else
        do j = 1, jsize
           do i = 1, isize
              !! Use second order
              k = 1
              if (bc0==1) then ! Zero grad
                 gradphi(i, j, k) = zero
              else ! Fixed value
                 gradphi(i, j, k) = (phi(i, j, k + 1) - phi(i, j, k)) / dz
              endif
              do k = 2, 3
                 gradphi(i, j, k) = (phi(i, j, k + 1) - phi(i, j, k - 1)) / (two * dz)
              enddo

              do k = ksize - 2, ksize - 1
                 gradphi(i, j, k) = (phi(i, j, k + 1) - phi(i, j, k - 1)) / (two * dz)
              enddo
              k = ksize
              if (bcn==1) then ! Zero grad
                 gradphi(i, j, k) = zero
              else
                 gradphi(i, j, k) = (phi(i, j, k) - phi(i, j, k - 1)) / dz
              endif
           enddo
        enddo
     endif
  endif
#+end_src

** Variable declarations

Because we have used ~implicit none~, we must declare all our variables.

#+NAME: src:weno5-declarations.f90
#+begin_src f90
  integer, intent(in) :: axis
  integer, intent(in) :: bc0, bcn
  integer, intent(in) :: isize, jsize, ksize
  real(kind=8), intent(in) :: dx, dy, dz
  real(kind=8), dimension(isize, jsize, ksize), intent(in) :: phi
  real(kind=8), dimension(isize, jsize, ksize), intent(in) :: advvel

  real(kind=8), dimension(isize, jsize, ksize), intent(inout) :: gradphi

  integer :: i, j, k
  integer :: istep, jstep, kstep
  integer :: istart, jstart, kstart, iend, jend, kend
  integer :: im1, im2, im3, ip1, ip2
  integer :: jm1, jm2, jm3, jp1, jp2
  integer :: km1, km2, km3, kp1, kp2
  real(kind=8), parameter :: e = 1.0d-16
  real(kind=8), parameter :: zero = 0.d0, &
       one = 1.d0, &
       two = 2.d0, &
       three = 3.d0, &
       four = 4.d0, &
       five = 5.d0, &
       six = 6.d0, &
       seven = 7.d0, &
       ten = 10.d0, &
       eleven = 11.d0, &
       twelve = 12.d0, &
       thirteen = 13.d0

  real(kind=8) :: q1, q2, q3, q4, q5
  real(kind=8) :: a1, a2, a3
  real(kind=8) :: w1, w2, w3
  real(kind=8) :: is1, is2, is3
  real(kind=8) :: dsign
  real(kind=8) :: deltax
#+end_src
** Testing

#+NAME: src:test-weno5-sin.py
#+begin_src python :noweb no-export :tangle weno-test.py
  <<src:import.py>>

  <<src:dom-f-def.py>>

  # Test x
  <<src:xsetup.py>>
  <<src:xinit.py>>
  <<src:gradx.py>>
  <<src:plotx.py>>

  # Test with discontinuity
  <<src:shift.py>>
  <<src:test-discontinuous.py>>
#+end_src

#+NAME: src:import.py
#+begin_src python
  import math
  import numpy as np
  import matplotlib.pyplot as plt

  import weno
  weno5 = weno.weno.weno5
#+end_src

#+NAME: src:dom-f-def.py
#+begin_src python
  N = 100
  L = 2 * math.pi

  dx = L / (N - 1.0)
  x = []
  f = []
  fp = []
  for i in range(N):
    x.append(i * dx)
    f.append(math.sin(x[i]))
    fp.append(math.cos(x[i]))
#+end_src

#+NAME: src:xsetup.py
#+begin_src python
  u = np.zeros((N, 1, 1), dtype=np.float64, order="F")
  phi = np.zeros((N, 1, 1), dtype=np.float64, order="F")
  gradphi = np.zeros((N, 1, 1), dtype=np.float64, order="F")
#+end_src

#+NAME: src:xinit.py
#+begin_src python
  for i in range(N):
    for j in range(1):
      for k in range(1):
        u[i][j][k] = 1.0
        phi[i][j][k] = f[i]
        gradphi[i][j][k] = 0.0
#+end_src

#+NAME: src:gradx.py
#+begin_src python
  weno5(gradphi, phi, u, 1, 2, 2, dx, dx, dx)
#+end_src

#+NAME: src:plotx.py
#+begin_src python :exports none
  plt.plot(x, gradphi[:,0,0], marker="o")
  plt.plot(x, fp)
  plt.title("Test x-derivative (smooth)")
  plt.savefig("weno-smoothx.eps", bbox_inches="tight")
  plt.close()
#+end_src

#+NAME: src:shift.py
#+begin_src python
  for i in range(N/2, N):
    f[i] += 1
#+end_src

#+NAME: src:test-discontinuous.py
#+begin_src python
  # Test x
  u = np.zeros((N, 1, 1), dtype=np.float64, order="F")
  phi = np.zeros((N, 1, 1), dtype=np.float64, order="F")
  gradphi = np.zeros((N, 1, 1), dtype=np.float64, order="F")
  for i in range(N):
    for j in range(1):
      for k in range(1):
        u[i][j][k] = 1.0
        phi[i][j][k] = f[i]
        gradphi[i][j][k] = 0.0

  weno5(gradphi, phi, u, 1, 2, 2, dx, dx, dx)

  fpc = np.zeros(N)
  for i in range(N):
    fpc[i] = gradphi[i][0][0]
  plt.plot(x, fpc, marker="o")
  plt.title("Test x-derivative (discontinuous)")
  plt.savefig("weno-discontinuousx.eps")
  plt.close()
#+end_src
