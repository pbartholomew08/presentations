#+TITLE: Developing Fortran using Python and Literate Programming
#+AUTHOR: Paul Bartholomew, Sylvain Laizet
#+DATE: September 2019

#+OPTIONS: toc:t
#+OPTIONS: H:2

#+STARTUP: beamer
#+LATEX_CLASS: beamer

#+LATEX_HEADER: \usecolortheme{Imperial}
#+LATEX_HEADER: \usepackage{booktabs}
#+LATEX_HEADER: \usepackage{caption}
#+LATEX_HEADER: \usepackage{subcaption}
#+LATEX_HEADER: \usepackage{amsfonts}
#+LATEX_HEADER: \usepackage{epstopdf}
#+LATEX_HEADER: \usepackage{multimedia}

# Use UK date format
#+LATEX_HEADER: \usepackage{datetime}
#+LATEX_HEADER: \let\dateUKenglish\relax
#+LATEX_HEADER: \newdateformat{dateUKenglish}{\THEDAY~\monthname[\THEMONTH] \THEYEAR}

# Imperial College Logo, not to be changed!
#+LATEX_HEADER: \institute{\includegraphics[height=0.7cm]{Imperial_1_Pantone_solid.eps}}

# # To repeat TOC at each section
# #+LATEX_HEADER: \AtBeginSection[]{\begin{frame}<beamer>\frametitle{\insertsection}\tableofcontents[currentsection]\end{frame}}

* Introduction

** My programming career

- Seems to have gone backwards:
  - ``Progress'': =FORTRAN= -> =C= -> =Python=
  - Experience: =Python= -> =C= -> =FORTRAN=

** Literate programming: an old idea

- Introduced by Donald Knuth in 1984
#+begin_quote
I believe that the time is ripe for significantly better documentation of programs, and that we can
best achieve this by considering programs to be works of literature.
Hence, my title: "Literate Programming."
#+end_quote
#+begin_quote
Instead of imagining that our main task is to instruct a computer what to do, let us concentrate on
explaining to human beings what we want a computer to do.
#+end_quote
- Doesn't seem to have caught on
- Could be well suited for scientific computing

** Exploring literate programming

*** Left
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

- Fits very well for producing reports
- Can combine
  - Processing of result
  - Display of result
  - Discussion of results
- =Jupyter= does something like this
- Can we take this idea further?

*** Right
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+CAPTION: Sections of report on Taylor Green Vortex
#+ATTR_LATEX: :width \columnwidth
[[./figures/tgv-literate.png]]

** The problem

- =Incompact3d= is a CFD code for simulating incompressible turbulent flows
- Want to develop a free-surface solver

#+CAPTION: Water surface with submerged obstacles
#+ATTR_LATEX: :width 0.575 \textwidth
[[./figures/mcsherry-freesurface.png]]

** The problem (cont.)

*** Left
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

- The schemes implemented in =Incompact3d= are ill-suited to these problems

#+CAPTION: Illustration of Gibbs' phenomenon
#+ATTR_LATEX: :width \columnwidth
[[./figures/gibbs-phenomenon.png]]

*** Right
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

- =WENO= schemes provide high-order accuracy without being susceptible to oscillations
  - Could simply code this in Fortran
  - Would like to leave behind something that is understandable
  - Testing code /inside/ a complex program is difficult

* Implementing a =WENO= scheme

** ~WENO~ schemes

- Evaluate several stencils

#+ATTR_LATEX: :width 0.6\textwidth
[[./figures/weno-stencil.png]]

- Check for "/smoothness/"
- Combine /smooth/ stencils to obtain higher order approximation

** ~WENO~ gradient computation

*** Left
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

- Weighted combination of stencils
\begin{equation*}
  \begin{split}
    \left.\frac{\partial\phi}{\partial x}\right|_i &=
    \begin{cases}
      \left.\frac{\partial\phi}{\partial x}\right|^-_i & u > 0 \\
      \left.\frac{\partial\phi}{\partial x}\right|^+_i & u < 0
    \end{cases} \\
    \left.\frac{\partial\phi}{\partial x}\right|^{\pm}_i &= \left[ \omega_1 \left( 2 q^{\pm}_1 + 7
        q^{\pm}_2 + 11 q^{\pm}_3 \right) \right.  \\
    & + \omega_2 \left( -q^{\pm}_2 + 5q^{\pm}_3 + 2q^{\pm}_4 \right) \\
    & \left.+ \omega_3 \left( 2q^{\pm}_3 + 5q^{\pm}_4 - q^{\pm}_5 \right) \right] / 6
  \end{split}
\end{equation*}

*** Right
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+CAPTION: Evaluation of \partial\phi/\partial{}x using fifth-order =WENO= scheme.
#+NAME: src:calcgrad.f90
#+begin_src f90
  gradphi(i,j,k)=&
       w1*(2.0*q1-7.0*q2+11.0*q3)&
       +w2*(-q2+5.0*q3+2.0*q4)&
       +w3*(2.0*q3+5.0*q4-q5)
  gradphi(i,j,k)=gradphi(i,j,k)/6.0
#+end_src

** Stencil computation

*** Left
:PROPERTIES:
:BEAMER_COL: 0.6
:END:

- Stencils are defined based on fluxes
\begin{equation*}
  \begin{split}
    q^{\pm}_1 = \frac{\phi_{i-2} - \phi_{i-3}}{\Delta x},&\ 
    q^{\pm}_2 = \frac{\phi_{i-1} - \phi_{i-2}}{\Delta x}, \\
    q^{\pm}_3 = \frac{\phi_i - \phi_{i-1}}{\Delta x},&\
    q^{\pm}_4 = \frac{\phi_{i+1} - \phi_i}{\Delta x}, \\
    q^{\pm}_5 =& \frac{\phi_{i+2} - \phi_{i+1}}{\Delta x},
  \end{split}
\end{equation*}

- They are /symmetric/ about the gradient evaluation point $x_i$

*** Right
:PROPERTIES:
:BEAMER_COL: 0.4
:END:

#+CAPTION: Stencil evaluation for fifth-order =WENO= scheme.
#+NAME: src:calcq.f90
#+begin_src f90
  q1=dsign*(phi(im2,jm2,km2)-phi(im3,jm3,km3))/deltax
  q2=dsign*(phi(im1,jm1,km1)-phi(im2,jm2,km2))/deltax
  q3=dsign*(phi(i,j,k)-phi(im1,jm1,km1))/deltax
  q4=dsign*(phi(ip1,jp1,kp1)-phi(i,j,k))/deltax
  q5=dsign*(phi(ip2,jp2,kp2)-phi(ip1,jp1,kp1))/deltax
#+end_src

** The stencil weights

*** Left
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

- The weights are the key to =weno=
  - Smooth regions have $\approx$ weights $\rightarrow$ high-order
  - If stencil $k$ contains discontinuity $\omega_{k}\rightarrow0$
- Defined as
\begin{equation*}
  \omega_k = \frac{\alpha_k}{\sum_l \alpha_l}
\end{equation*}
# - *N.B.* \sum_{k}\omega_{k}=1

*** Right
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+CAPTION: Weight calculation for fifth-order =WENO= scheme.
#+NAME: src:calcweights.f90
#+begin_src f90
  w1 = a1 / (a1 + a2 + a3)
  w2 = a2 / (a1 + a2 + a3)
  w3 = a3 / (a1 + a2 + a3)
#+end_src

** The weight coefficients

*** Left
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

\begin{equation*}
  \alpha_k = \frac{C_k}{{\left( IS_k + \varepsilon \right)}^2}
\end{equation*}

#+CAPTION: Calculating the weighting coefficients
#+begin_src f90 :noweb no-export
  <<src:calc-indicators.f90>>
  <<src:calc-a1.f90>>
  <<src:calc-a2.f90>>
  <<src:calc-a3.f90>>
#+end_src

#+CAPTION: Calculating coefficient $\alpha_1$
#+NAME: src:calc-a1.f90
#+begin_src f90
  a1=1.0/(e+is1)**2/10.0
#+end_src
#+NAME: src:calc-a2.f90
#+begin_src f90 :exports none
  a2=6.0/(e+is2)**2/10.0
#+end_src
#+NAME: src:calc-a3.f90
#+begin_src f90 :exports none
  a3=3.0/(e+is3)**2/10.0
#+end_src

*** Right
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+CAPTION: Calculating the smoothness indicators
#+NAME: src:calc-indicators.f90
#+begin_src f90 :noweb no-export
  <<src:calc-is1.f90>>
  <<src:calc-is2.f90>>
  <<src:calc-is3.f90>>
#+end_src

#+CAPTION: Calculating $IS_1$
#+NAME: calc-is1.f90
#+begin_src f90
  is1=(13.0/12.0) &
       ,*(phi(im2,jm2,km2)-2.0*phi(im1,jm1,km1)+phi(i,j,k))**2 &
       +(phi(im2,jm2,km2)-4.0*phi(im1,jm1,km1)+three*phi(i,j,k))**2 &
       /4.0
#+end_src
#+NAME: calc-is2.f90
#+begin_src f90 :exports none
  is2=(13.0/12.0)*(phi(im1,jm1,km1)-2.0*phi(i,j,k)+phi(ip1,jp1,kp1))**2&
       +(phi(im1,jm1,km1)-phi(ip1,jp1,kp1))**2/4.0
#+end_src
#+NAME: calc-is3.f90
#+begin_src f90 :exports none
  is3=(13.0/12.0)*(phi(i,j,k)-2.0*phi(ip1,jp1,kp1)+phi(ip2,jp2,kp2))**2&
       +(3.0*phi(i,j,k)-4.0*phi(ip1,jp1,kp1)+phi(ip2,jp2,kp2))**2/4.0
#+end_src

** The =weno= module

*** Left
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

Bringing it all together.

#+CAPTION: The ~weno~ module.
#+NAME: src:weno.f90
#+begin_src f90 :noweb no-export :tangle weno.f90
  module weno
    implicit none
    private
    public :: weno5
  contains
    <<src:weno5.f90>>
  endmodule weno
#+end_src

*** Right
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+CAPTION: =WENO= subroutine definition.
#+NAME: src:weno5.f90
#+begin_src f90 :noweb no-export
  subroutine weno5(gradphi, phi, advvel, &
       axis, bc0, bcn, &
       isize, jsize, ksize, &
       dx, dy, dz)
    implicit none
    <<src:weno5-declarations.f90>>
    <<src:weno5-setup.f90>>
    do k = kstart, kend
       do j = jstart, jend
          !! Note, if axis==2 and y is stretched, need to set deltax here
          do i = istart, iend
             <<src:sign.f90>>
             <<src:calcq.f90>>
             <<src:calcsmooth.f90>>
             <<src:calcweights.f90>>
             <<src:calcgrad.f90>>
          enddo
          <<src:bcx.f90>>
       enddo
       <<src:bcy.f90>>
    enddo
    <<src:bcz.f90>>
  endsubroutine weno5
#+end_src

* Testing

** Testing

Two possible approaches to testing the implementation:
1) Add module directly to =Xcompact3d=
2) Test module independently before adding to =Xcompact3d=

Using =f2py= we can easily build =weno.f90= as a standalone module and call from Python to test
- Easy to setup test cases
- Rapid feedback

** Testing on a smooth function

*** Left
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

Consider
\begin{equation*}
  \begin{split}
    f\left(x\right) &= \sin\left(x\right) \\
    \Rightarrow f'\left(x\right) &= \cos\left(x\right)
  \end{split}
\end{equation*}

#+CAPTION: Testing the x-derivative
#+begin_src python :noweb yes
  <<src:xinit.py>>
  <<src:gradx.py>>
  <<src:plotx.py>>
#+end_src

#+NAME: src:xinit.py
#+begin_src python :exports none
  for i in range(N):
    for j in range(1):
      for k in range(1):
        u[i][j][k] = 1.0
        phi[i][j][k] = f[i]
        gradphi[i][j][k] = 0.0
#+end_src
#+NAME: src:gradx.py
#+begin_src python :exports none
  weno5(gradphi, phi, u, 1, 2, 2, dx, dx, dx)
#+end_src
#+NAME: src:plotx.py
#+begin_src python :exports none
  plt.plot(x, fpc, marker="o")
  plt.plot(x, fp)
  plt.title("Test x-derivative (smooth)")
  plt.savefig("weno-smoothx.eps", bbox_inches="tight")
#+end_src

*** Right
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+CAPTION: Comparison of numerical and analytical derivative of $f\left(x\right)=\sin\left(x\right)$
#+ATTR_LATEX: :width \columnwidth
[[./figures/weno-smoothx.eps]]

** Application to a pure advection equation

*** Left
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

- Motivating implementation of ~weno5~

\begin{equation*}
  \frac{\partial\phi}{\partial t} + \boldsymbol{u}\cdot\boldsymbol{\nabla}\phi = 0
\end{equation*}

- In periodic domain, $\phi$ simply moves with velocity $u$
- Simple to implement in =Python= using ~weno5~ + ~scipy~'s ode solvers
- Domain $x\in\left[-1, 1\right]$ discretised with 200 points

*** Right
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+CAPTION: Comparison of analytical solution and numerical solutions at $t=8, 10$
#+ATTR_LATEX: :width \columnwidth
[[./figures/adv_test.eps]]

* Conclusion

** Conclusion

*** Left
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

- A =weno= scheme was implemented and has been incorporated into =Xcompact3d=
- @@latex:\color{green}{\textbf{+}}@@ :: Using literate programming we can write programs in a way
     that makes sense to us
- @@latex:\color{green}{\textbf{+}}@@ :: Explanatory document automatically generated
- @@latex:\color{red}{\textbf{--}}@@ :: Tooling isn't as strong as traditional tooling

*** Right
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

- Using =f2py= simplifies testing
- @@latex:\color{green}{\textbf{+}}@@ :: Quicker feedback on tests
- @@latex:\color{green}{\textbf{+}}@@ :: Can explore results using =Python=
- @@latex:\color{green}{\textbf{+}}@@ :: Using literate programming can embed testing + results into
     same source document
